<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Control and signal blocks · Sims.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../../versions.js"></script></head><body><nav class="toc"><h1>Sims.jl</h1><form class="search" action="../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="../basics.html">Basics</a></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="../api/sim.html">Simulations</a></li><li><a class="toctext" href="../api/main.html">Building models</a></li><li><a class="toctext" href="../api/utils.html">Utilities</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="types.html">The Sims standard library</a></li><li><a class="toctext" href="kinetics.html">Chemical kinetics</a></li><li class="current"><a class="toctext" href="blocks.html">Control and signal blocks</a><ul class="internal"><li><a class="toctext" href="#Continuous-linear-1">Continuous linear</a></li><li><a class="toctext" href="#Nonlinear-1">Nonlinear</a></li></ul></li><li><a class="toctext" href="electrical.html">Analog electrical models</a></li><li><a class="toctext" href="heat_transfer.html">Heat transfer models</a></li><li><a class="toctext" href="powersystems.html">Power systems models</a></li><li><a class="toctext" href="rotational.html">Rotational mechanics</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/basics.html">Examples using basic models</a></li><li><a class="toctext" href="../examples/lib.html">Sims.Lib</a></li><li><a class="toctext" href="../examples/tiller.html">Tiller examples</a></li></ul></li><li><a class="toctext" href="../design.html">Design</a></li><li><a class="toctext" href="../NEWS.html">Release notes</a></li><li><a class="toctext" href="../LICENSE.html">License</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href="blocks.html">Control and signal blocks</a></li></ul><a class="edit-page" href="https://github.com/tshort/Sims.jl/tree/753a74faa605fef22449b3f35bbc0f5024e3cdc3/docs/src/lib/blocks.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><ul><li><a href="blocks.html#Control-and-signal-blocks-1">Control and signal blocks</a></li><ul><li><a href="blocks.html#Continuous-linear-1">Continuous linear</a></li><ul><li><a href="blocks.html#Integrator-1">Integrator</a></li><li><a href="blocks.html#Derivative-1">Derivative</a></li><li><a href="blocks.html#FirstOrder-1">FirstOrder</a></li><li><a href="blocks.html#LimPID-1">LimPID</a></li><li><a href="blocks.html#StateSpace-1">StateSpace</a></li><li><a href="blocks.html#TransferFunction-1">TransferFunction</a></li></ul><li><a href="blocks.html#Nonlinear-1">Nonlinear</a></li><ul><li><a href="blocks.html#Limiter-1">Limiter</a></li><li><a href="blocks.html#Step-1">Step</a></li><li><a href="blocks.html#DeadZone-1">DeadZone</a></li><li><a href="blocks.html#BooleanPulse-1">BooleanPulse</a></li></ul></ul></ul><h1><a class="nav-anchor" id="Control-and-signal-blocks-1" href="#Control-and-signal-blocks-1">Control and signal blocks</a></h1><p>These components are modeled after the <code>Modelica.Blocks.*</code> library.</p><h2><a class="nav-anchor" id="Continuous-linear-1" href="#Continuous-linear-1">Continuous linear</a></h2><h3><a class="nav-anchor" id="Integrator-1" href="#Integrator-1">Integrator</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.Lib.Integrator" href="#Sims.Lib.Integrator"><code>Sims.Lib.Integrator</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Output the integral of the input signals</p><pre><code class="language-julia">Integrator(u::Signal, y::Signal, k,       y_start = 0.0)
Integrator(u::Signal, y::Signal; k = 1.0, y_start = 0.0) # keyword arg version</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>u::Signal</code> : input</p></li><li><p><code>y::Signal</code> : output</p></li></ul><p><strong>Keyword/Optional Arguments</strong></p><ul><li><p><code>k</code> : integrator gains</p></li><li><p><code>y_start</code> : output initial value</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/tshort/Sims.jl/tree/753a74faa605fef22449b3f35bbc0f5024e3cdc3/src/../lib/blocks.jl#L27-L45">source</a><br/></section><h3><a class="nav-anchor" id="Derivative-1" href="#Derivative-1">Derivative</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.Lib.Derivative" href="#Sims.Lib.Derivative"><code>Sims.Lib.Derivative</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Approximated derivative block</p><p>This blocks defines the transfer function between the input <code>u</code> and the output <code>y</code> element-wise as the approximated derivative:</p><pre><code class="language-none">             k[i] * s
     y[i] = ------------ * u[i]
            T[i] * s + 1</code></pre><p>If you would like to be able to change easily between different transfer functions (FirstOrder, SecondOrder, ... ) by changing parameters, use the general block TransferFunction instead and model a derivative block with parameters as:</p><pre><code class="language-julia">    b = [k,0]; a = [T, 1]</code></pre><pre><code class="language-julia">Derivative(u::Signal, y::Signal, T = 1.0, k = 1.0, x_start = 0.0, y_start = 0.0)
Derivative(u::Signal, y::Signal; T = 1.0, k = 1.0, x_start = 0.0, y_start = 0.0)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>u::Signal</code> : input</p></li><li><p><code>y::Signal</code> : output</p></li></ul><p><strong>Keyword/Optional Arguments</strong></p><ul><li><p><code>k</code> : gains</p></li><li><p><code>T</code> : Time constants [sec]</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/tshort/Sims.jl/tree/753a74faa605fef22449b3f35bbc0f5024e3cdc3/src/../lib/blocks.jl#L57-L93">source</a><br/></section><h3><a class="nav-anchor" id="FirstOrder-1" href="#FirstOrder-1">FirstOrder</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.Lib.FirstOrder" href="#Sims.Lib.FirstOrder"><code>Sims.Lib.FirstOrder</code></a> — <span class="docstring-category">Function</span>.</div><div><p>First order transfer function block (= 1 pole)</p><p>This blocks defines the transfer function between the input u=inPort.signal and the output y=outPort.signal element-wise as first order system:</p><pre><code class="language-none">               k[i]
     y[i] = ------------ * u[i]
            T[i] * s + 1</code></pre><p>If you would like to be able to change easily between different transfer functions (FirstOrder, SecondOrder, ... ) by changing parameters, use the general block TransferFunction instead and model a derivative block with parameters as:</p><pre><code class="language-julia">    b = [k,0]; a = [T, 1]</code></pre><pre><code class="language-julia">FirstOrder(u::Signal, y::Signal, T = 1.0, k = 1.0, y_start = 0.0)
FirstOrder(u::Signal, y::Signal; T = 1.0, k = 1.0, y_start = 0.0)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>u::Signal</code> : input</p></li><li><p><code>y::Signal</code> : output</p></li></ul><p><strong>Keyword/Optional Arguments</strong></p><ul><li><p><code>k</code> : gains</p></li><li><p><code>T</code> : Time constants [sec]</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/tshort/Sims.jl/tree/753a74faa605fef22449b3f35bbc0f5024e3cdc3/src/../lib/blocks.jl#L115-L150">source</a><br/></section><h3><a class="nav-anchor" id="LimPID-1" href="#LimPID-1">LimPID</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.Lib.LimPID" href="#Sims.Lib.LimPID"><code>Sims.Lib.LimPID</code></a> — <span class="docstring-category">Function</span>.</div><div><p>PID controller with limited output, anti-windup compensation and setpoint weighting</p><p><img src="http://www.maplesoft.com/documentation_center/online_manuals/modelica/Modelica.Blocks.Continuous.LimPIDD.png" alt="diagram"/></p><pre><code class="language-julia">LimPID(u_s::Signal, u_m::Signal, y::Signal, 
       controllerType = &quot;PID&quot;,
       k = 1.0,      
       Ti = 1.0,    
       Td = 1.0,   
       yMax = 1.0,   
       yMin = -yMax, 
       wp = 1.0,     
       wd = 0.0,     
       Ni = 0.9,    
       Nd = 10.0,    
       xi_start = 0.0, 
       xd_start = 0.0,
       y_start = 0.0)
LimPID(u_s::Signal, u_m::Signal, y::Signal; 
       controllerType = &quot;PID&quot;,
       k = 1.0,      
       Ti = 1.0,    
       Td = 1.0,   
       yMax = 1.0,   
       yMin = -yMax, 
       wp = 1.0,     
       wd = 0.0,     
       Ni = 0.9,    
       Nd = 10.0,    
       xi_start = 0.0, 
       xd_start = 0.0,
       y_start = 0.0)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>u_s::Signal</code> : input setpoint</p></li><li><p><code>u_m::Signal</code> : input measurement</p></li><li><p><code>y_s::Signal</code> : output</p></li></ul><p><strong>Keyword/Optional Arguments</strong></p><ul><li><p><code>k</code>    : Gain of PID block                                  </p></li><li><p><code>Ti</code>   : Time constant of Integrator block [s]</p></li><li><p><code>Td</code>   : Time constant of Derivative block [s]</p></li><li><p><code>yMax</code> : Upper limit of output</p></li><li><p><code>yMin</code> : Lower limit of output</p></li><li><p><code>wp</code>   : Set-point weight for Proportional block (0..1)</p></li><li><p><code>wd</code>   : Set-point weight for Derivative block (0..1)</p></li><li><p><code>Ni</code>   : Ni*Ti is time constant of anti-windup compensation</p></li><li><p><code>Nd</code>   : The higher Nd, the more ideal the derivative block</p></li></ul><p><strong>Details</strong></p><p>This is a PID controller incorporating several practical aspects. It is designed according to chapter 3 of the book:</p><p>K. Astroem, T. Haegglund: PID Controllers: Theory, Design, and Tuning. 2nd edition, 1995.</p><p>Besides the additive proportional, integral and derivative part of this controller, the following practical aspects are included:</p><ul><li><p>The output of this controller is limited. If the controller is in its limits, anti-windup compensation is activated to drive the integrator state to zero.</p></li><li><p>The high-frequency gain of the derivative part is limited to avoid excessive amplification of measurement noise.</p></li><li><p>Setpoint weighting is present, which allows to weight the setpoint in the proportional and the derivative part independantly from the measurement. The controller will respond to load disturbances and measurement noise independantly of this setting (parameters wp, wd). However, setpoint changes will depend on this setting. For example, it is useful to set the setpoint weight wd for the derivative part to zero, if steps may occur in the setpoint signal.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/tshort/Sims.jl/tree/753a74faa605fef22449b3f35bbc0f5024e3cdc3/src/../lib/blocks.jl#L166-L247">source</a><br/></section><h3><a class="nav-anchor" id="StateSpace-1" href="#StateSpace-1">StateSpace</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.Lib.StateSpace" href="#Sims.Lib.StateSpace"><code>Sims.Lib.StateSpace</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Linear state space system</p><p>Modelica.Blocks.Continuous.StateSpace Information</p><p>The State Space block defines the relation between the input u=inPort.signal and the output y=outPort.signal in state space form:</p><pre><code class="language-none">der(x) = A * x + B * u
    y  = C * x + D * u</code></pre><p>The input is a vector of length nu, the output is a vector of length ny and nx is the number of states. Accordingly</p><pre><code class="language-none">    A has the dimension: A(nx,nx), 
    B has the dimension: B(nx,nu), 
    C has the dimension: C(ny,nx), 
    D has the dimension: D(ny,nu)</code></pre><p>Example:</p><pre><code class="language-julia">     StateSpace(u, y; A = [0.12, 2; 3, 1.5], 
                      B = [2,    7; 3, 1],
                      C = [0.1, 2],
                      D = zeros(length(y),length(u)))</code></pre><p>results in the following equations:</p><pre><code class="language-none">  [der(x[1])]   [0.12  2.00] [x[1]]   [2.0  7.0] [u[1]]
  [         ] = [          ]*[    ] + [        ]*[    ]
  [der(x[2])]   [3.00  1.50] [x[2]]   [0.1  2.0] [u[2]]

                             [x[1]]            [u[1]]
       y[1]   = [0.1  2.0] * [    ] + [0  0] * [    ]
                             [x[2]]            [u[2]]</code></pre><pre><code class="language-julia">StateSpace(u::Signal, y::Signal, A = [1.0], B = [1.0], C = [1.0], D = [0.0])
StateSpace(u::Signal, y::Signal; A = [1.0], B = [1.0], C = [1.0], D = [0.0])</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>u::Signal</code> : input</p></li><li><p><code>y::Signal</code> : output</p></li></ul><p><strong>Keyword/Optional Arguments</strong></p><ul><li><p><code>A</code> : Matrix A of state space model</p></li><li><p><code>B</code> : Vector B of state space model</p></li><li><p><code>C</code> : Vector C of state space model</p></li><li><p><code>D</code> : Matrix D of state space model</p></li></ul><p><strong>Details</strong></p><p><strong>Example</strong></p><pre><code class="language-julia"></code></pre><p>NOTE: untested / probably broken</p></div><a class="source-link" target="_blank" href="https://github.com/tshort/Sims.jl/tree/753a74faa605fef22449b3f35bbc0f5024e3cdc3/src/../lib/blocks.jl#L298-L367">source</a><br/></section><h3><a class="nav-anchor" id="TransferFunction-1" href="#TransferFunction-1">TransferFunction</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.Lib.TransferFunction" href="#Sims.Lib.TransferFunction"><code>Sims.Lib.TransferFunction</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Linear transfer function</p><p>This block defines the transfer function between the input u=inPort.signal[1] and the output y=outPort.signal[1] as (nb = dimension of b, na = dimension of a):</p><pre><code class="language-none">           b[1]*s^[nb-1] + b[2]*s^[nb-2] + ... + b[nb]
   y(s) = --------------------------------------------- * u(s)
           a[1]*s^[na-1] + a[2]*s^[na-2] + ... + a[na]</code></pre><p>State variables x are defined according to controller canonical form. Initial values of the states can be set as start values of x.</p><p>Example:</p><pre><code class="language-julia">     TransferFunction(u, y, b = [2,4], a = [1,3])</code></pre><p>results in the following transfer function:</p><pre><code class="language-none">        2*s + 4
   y = --------- * u
         s + 3</code></pre><pre><code class="language-julia">TransferFunction(u::Signal, y::Signal, b = [1], a = [1])
TransferFunction(u::Signal, y::Signal; b = [1], a = [1])</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>u::Signal</code> : input</p></li><li><p><code>y::Signal</code> : output</p></li></ul><p><strong>Keyword/Optional Arguments</strong></p><ul><li><p><code>b</code> : Numerator coefficients of transfer function</p></li><li><p><code>a</code> : Denominator coefficients of transfer function</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/tshort/Sims.jl/tree/753a74faa605fef22449b3f35bbc0f5024e3cdc3/src/../lib/blocks.jl#L387-L432">source</a><br/></section><h2><a class="nav-anchor" id="Nonlinear-1" href="#Nonlinear-1">Nonlinear</a></h2><h3><a class="nav-anchor" id="Limiter-1" href="#Limiter-1">Limiter</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.Lib.Limiter" href="#Sims.Lib.Limiter"><code>Sims.Lib.Limiter</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Limit the range of a signal</p><p>The Limiter block passes its input signal as output signal as long as the input is within the specified upper and lower limits. If this is not the case, the corresponding limits are passed as output.</p><pre><code class="language-julia">Limiter(u::Signal, y::Signal, uMax = 1.0, uMin = -uMax)
Limiter(u::Signal, y::Signal; uMax = 1.0, uMin = -uMax)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>u::Signal</code> : input</p></li><li><p><code>y::Signal</code> : output</p></li></ul><p><strong>Keyword/Optional Arguments</strong></p><ul><li><p><code>uMax</code> : upper limits of signals</p></li><li><p><code>uMin</code> : lower limits of signals</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/tshort/Sims.jl/tree/753a74faa605fef22449b3f35bbc0f5024e3cdc3/src/../lib/blocks.jl#L471-L493">source</a><br/></section><h3><a class="nav-anchor" id="Step-1" href="#Step-1">Step</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.Lib.Step" href="#Sims.Lib.Step"><code>Sims.Lib.Step</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Generate step signals of type Real</p><pre><code class="language-julia">Step(y::Signal, height = 1.0, offset = 0.0, startTime = 0.0)
Step(y::Signal; height = 1.0, offset = 0.0, startTime = 0.0)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>u::Signal</code> : input</p></li><li><p><code>y::Signal</code> : output</p></li></ul><p><strong>Keyword/Optional Arguments</strong></p><ul><li><p><code>height</code> : heights of steps</p></li><li><p><code>offset</code> : offsets of output signals</p></li><li><p><code>startTime</code> : output = offset for time &lt; startTime [s]</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/tshort/Sims.jl/tree/753a74faa605fef22449b3f35bbc0f5024e3cdc3/src/../lib/blocks.jl#L512-L531">source</a><br/></section><h3><a class="nav-anchor" id="DeadZone-1" href="#DeadZone-1">DeadZone</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.Lib.DeadZone" href="#Sims.Lib.DeadZone"><code>Sims.Lib.DeadZone</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Provide a region of zero output</p><p>The DeadZone block defines a region of zero output.</p><p>If the input is within uMin ... uMax, the output is zero. Outside of this zone, the output is a linear function of the input with a slope of 1.</p><pre><code class="language-julia">DeadZone(u::Signal, y::Signal, uMax = 1.0, uMin = -uMax)
DeadZone(u::Signal, y::Signal; uMax = 1.0, uMin = -uMax)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>u::Signal</code> : input</p></li><li><p><code>y::Signal</code> : output</p></li></ul><p><strong>Keyword/Optional Arguments</strong></p><ul><li><p><code>uMax</code> : upper limits of signals</p></li><li><p><code>uMin</code> : lower limits of signals</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/tshort/Sims.jl/tree/753a74faa605fef22449b3f35bbc0f5024e3cdc3/src/../lib/blocks.jl#L550-L574">source</a><br/></section><h3><a class="nav-anchor" id="BooleanPulse-1" href="#BooleanPulse-1">BooleanPulse</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.Lib.BooleanPulse" href="#Sims.Lib.BooleanPulse"><code>Sims.Lib.BooleanPulse</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Generate a Discrete boolean pulse signal</p><pre><code class="language-julia">BooleanPulse(y, width = 50.0, period = 1.0, startTime = 0.0)
BooleanPulse(y; width = 50.0, period = 1.0, startTime = 0.0)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>y::Signal</code> : output signal</p></li></ul><p><strong>Keyword/Optional Arguments</strong></p><ul><li><p><code>width</code> : width of pulse in the percent of period [0 - 100]</p></li><li><p><code>period</code> : time for one period [sec]</p></li><li><p><code>startTime</code> : time instant of the first pulse [sec]</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/tshort/Sims.jl/tree/753a74faa605fef22449b3f35bbc0f5024e3cdc3/src/../lib/blocks.jl#L593-L611">source</a><br/></section><footer><hr/><a class="previous" href="kinetics.html"><span class="direction">Previous</span><span class="title">Chemical kinetics</span></a><a class="next" href="electrical.html"><span class="direction">Next</span><span class="title">Analog electrical models</span></a></footer></article></body></html>
