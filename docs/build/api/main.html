<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Building models · Sims.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../../versions.js"></script></head><body><nav class="toc"><h1>Sims.jl</h1><form class="search" action="../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="../basics.html">Basics</a></li><li><span class="toctext">API</span><ul><li class="current"><a class="toctext" href="main.html">Building models</a><ul class="internal"></ul></li><li><a class="toctext" href="sim.html">Simulations</a></li><li><a class="toctext" href="utils.html">Utilities</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/types.html">The Sims standard library</a></li><li><a class="toctext" href="../lib/kinetics.html">Chemical kinetics</a></li><li><a class="toctext" href="../lib/blocks.html">Control and signal blocks</a></li><li><a class="toctext" href="../lib/electrical.html">Analog electrical models</a></li><li><a class="toctext" href="../lib/heat_transfer.html">Heat transfer models</a></li><li><a class="toctext" href="../lib/powersystems.html">Power systems models</a></li><li><a class="toctext" href="../lib/rotational.html">Rotational mechanics</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/basics.html">Examples using basic models</a></li><li><a class="toctext" href="../examples/lib.html">Sims.Lib</a></li><li><a class="toctext" href="../examples/tiller.html">Tiller examples</a></li></ul></li><li><a class="toctext" href="../design.html">Design</a></li><li><a class="toctext" href="../NEWS.html">Release notes</a></li><li><a class="toctext" href="../LICENSE.html">License</a></li></ul></nav><article id="docs"><header><nav><ul><li>API</li><li><a href="main.html">Building models</a></li></ul></nav><hr/></header><ul><li><a href="main.html#Building-models-1">Building models</a></li><ul><ul><li><a href="main.html#verbosity-1">verbosity</a></li><li><a href="main.html#ModelType-1">ModelType</a></li><li><a href="main.html#UnknownVariable-1">UnknownVariable</a></li><li><a href="main.html#UnknownCategory-1">UnknownCategory</a></li><li><a href="main.html#DefaultUnknown-1">DefaultUnknown</a></li><li><a href="main.html#UnknownConstraint-1">UnknownConstraint</a></li><li><a href="main.html#Normal-1">Normal</a></li><li><a href="main.html#Negative-1">Negative</a></li><li><a href="main.html#NonNegative-1">NonNegative</a></li><li><a href="main.html#Positive-1">Positive</a></li><li><a href="main.html#NonPositive-1">NonPositive</a></li><li><a href="main.html#Unknown-1">Unknown</a></li><li><a href="main.html#is_unknown-1">is_unknown</a></li><li><a href="main.html#DerUnknown-1">DerUnknown</a></li><li><a href="main.html#der-1">der</a></li><li><a href="main.html#MExpr-1">MExpr</a></li><li><a href="main.html#mexpr-1">mexpr</a></li><li><a href="main.html#Equation-1">Equation</a></li><li><a href="main.html#Model-1">Model</a></li><li><a href="main.html#RefUnknown-1">RefUnknown</a></li><li><a href="main.html#value-1">value</a></li><li><a href="main.html#name-1">name</a></li><li><a href="main.html#compatible_values-1">compatible_values</a></li><li><a href="main.html#MTime-1">MTime</a></li><li><a href="main.html#RefBranch-1">RefBranch</a></li><li><a href="main.html#Branch-1">Branch</a></li><li><a href="main.html#InitialEquation-1">InitialEquation</a></li><li><a href="main.html#PassedUnknown-1">PassedUnknown</a></li><li><a href="main.html#delay-1">delay</a></li><li><a href="main.html#UnknownReactive-1">UnknownReactive</a></li><li><a href="main.html#Discrete-1">Discrete</a></li><li><a href="main.html#Parameter-1">Parameter</a></li><li><a href="main.html#reinit-1">reinit</a></li><li><a href="main.html#LeftVar-1">LeftVar</a></li><li><a href="main.html#lift-1">lift</a></li><li><a href="main.html#foldl-1">foldl</a></li><li><a href="main.html#@liftd-1">@liftd</a></li><li><a href="main.html#pre-1">pre</a></li><li><a href="main.html#Event-1">Event</a></li><li><a href="main.html#BoolEvent-1">BoolEvent</a></li><li><a href="main.html#ifelse-1">ifelse</a></li><li><a href="main.html#StructuralEvent-1">StructuralEvent</a></li><li><a href="main.html#@equations-1">@equations</a></li></ul></ul></ul><h1><a class="nav-anchor" id="Building-models-1" href="#Building-models-1">Building models</a></h1><p>The API for building models with Sims. Includes basic types, models, and functions.</p><h3><a class="nav-anchor" id="verbosity-1" href="#verbosity-1">verbosity</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.verbosity" href="#Sims.verbosity"><code>Sims.verbosity</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Control the verbosity of output.</p><pre><code class="language-julia">verbosity(i)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>i</code> : Int indicator with the following meanings:</p><ul><li><p><code>i == 0</code> : don&#39;t print information</p></li><li><p><code>i == 1</code> : minimal info</p></li><li><p><code>i == 2</code> : all info, including events</p></li></ul></li></ul><p>More options may be added in the future. This function is not exported, so you must qualify it as <code>Sims.verbosity(0)</code>.</p></div></section><h3><a class="nav-anchor" id="ModelType-1" href="#ModelType-1">ModelType</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.ModelType" href="#Sims.ModelType"><code>Sims.ModelType</code></a> — <span class="docstring-category">Type</span>.</div><div><p>The main overall abstract type in Sims.</p></div></section><h3><a class="nav-anchor" id="UnknownVariable-1" href="#UnknownVariable-1">UnknownVariable</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.UnknownVariable" href="#Sims.UnknownVariable"><code>Sims.UnknownVariable</code></a> — <span class="docstring-category">Type</span>.</div><div><p>An abstract type for variables to be solved. Examples include Unknown, DerUnknown, and Parameter.</p></div></section><h3><a class="nav-anchor" id="UnknownCategory-1" href="#UnknownCategory-1">UnknownCategory</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.UnknownCategory" href="#Sims.UnknownCategory"><code>Sims.UnknownCategory</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Categories of Unknown types; used to subtype Unknowns.</p></div></section><h3><a class="nav-anchor" id="DefaultUnknown-1" href="#DefaultUnknown-1">DefaultUnknown</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.DefaultUnknown" href="#Sims.DefaultUnknown"><code>Sims.DefaultUnknown</code></a> — <span class="docstring-category">Type</span>.</div><div><p>The default UnknownCategory.</p></div></section><h3><a class="nav-anchor" id="UnknownConstraint-1" href="#UnknownConstraint-1">UnknownConstraint</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.UnknownConstraint" href="#Sims.UnknownConstraint"><code>Sims.UnknownConstraint</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Categories of constraints on Unknowns; used to create positive, negative, etc., constraints.</p></div></section><h3><a class="nav-anchor" id="Normal-1" href="#Normal-1">Normal</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.Normal" href="#Sims.Normal"><code>Sims.Normal</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Indicates no constraint is imposed.</p></div></section><h3><a class="nav-anchor" id="Negative-1" href="#Negative-1">Negative</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.Negative" href="#Sims.Negative"><code>Sims.Negative</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Indicates unknowns of this type must be constrained to negative values.</p></div></section><h3><a class="nav-anchor" id="NonNegative-1" href="#NonNegative-1">NonNegative</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.NonNegative" href="#Sims.NonNegative"><code>Sims.NonNegative</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Indicates unknowns of this type must be constrained to positive or zero values.</p></div></section><h3><a class="nav-anchor" id="Positive-1" href="#Positive-1">Positive</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.Positive" href="#Sims.Positive"><code>Sims.Positive</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Indicates unknowns of this type must be constrained to positive values.</p></div></section><h3><a class="nav-anchor" id="NonPositive-1" href="#NonPositive-1">NonPositive</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.NonPositive" href="#Sims.NonPositive"><code>Sims.NonPositive</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Indicates unknowns of this type must be constrained to negative or zero values.</p></div></section><h3><a class="nav-anchor" id="Unknown-1" href="#Unknown-1">Unknown</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.Unknown" href="#Sims.Unknown"><code>Sims.Unknown</code></a> — <span class="docstring-category">Type</span>.</div><div><p>An Unknown represents variables to be solved in Sims. An <code>Unknown</code> is a symbolic type. When used in Julia expressions, Unknowns combine into <code>MExpr</code>s which are symbolic representations of equations.</p><p>Expressions (of type MExpr) are built up based on Unknown&#39;s. Unknown is a symbol with a uniquely generated symbol name. If you have</p><p>Unknowns can contain Float64, Complex, and Array{Float64} values. Additionally, Unknowns can be extended to support other types. All Unknown types currently map to positions in an Array{Float64}.</p><p>In addition to a value, Unknowns can carry additional metadata, including an identification symbol and a label. In the future, unit information may be added.</p><p>Unknowns can also have type parameters. Two parameters are provided:</p><ul><li><p><code>T</code>: type of unknown; several are defined in Sims.Lib, including <code>UVoltage</code> and <code>UAngularVelocity</code>.</p></li><li><p><code>C</code>: contstraint on the unknown; possibilities include <code>Normal</code> (the default), <code>Positive</code>, <code>NonNegative</code>, `<code>Negative</code>, and <code>NonPositive</code>.</p></li></ul><p>As an example, <code>Voltage</code> is defined as <code>Unknown{UVoltage,Normal}</code> in the standard library. The <code>UVoltage</code> type parameter is a marker to distinguish those Unknown from others. Users can add their own Unknown types. Different Unknown types makes it easier to dispatch on model arguments.</p><pre><code class="language-julia">Unknown(s::Symbol, x, label::AbstractString, fixed::Bool)
Unknown()
Unknown(x)
Unknown(s::Symbol, label::AbstractString)
Unknown(x, label::AbstractString)
Unknown(label::AbstractString)
Unknown(s::Symbol, x, fixed::Bool)
Unknown(s::Symbol, x)
Unknown{T,C}(s::Symbol, x, label::AbstractString, fixed::Bool)
Unknown{T,C}()
Unknown{T,C}(x)
Unknown{T,C}(s::Symbol, label::AbstractString)
Unknown{T,C}(x, label::AbstractString)
Unknown{T,C}(label::AbstractString)
Unknown{T,C}(s::Symbol, x, fixed::Bool)
Unknown{T,C}(s::Symbol, x)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>s::Symbol</code> : identification symbol, defaults to <code>gensym()</code></p></li><li><p><code>x</code> : initial value and type information, defaults to 0.0</p></li><li><p><code>label::AbstractString</code> : labeling string, defaults to &quot;&quot;</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">  a = 4
  b = Unknown(3.0, &quot;len&quot;)
  a * b + b^2</code></pre></div></section><h3><a class="nav-anchor" id="is_unknown-1" href="#is_unknown-1">is_unknown</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.is_unknown" href="#Sims.is_unknown"><code>Sims.is_unknown</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Is the object an UnknownVariable?</p></div></section><h3><a class="nav-anchor" id="DerUnknown-1" href="#DerUnknown-1">DerUnknown</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.DerUnknown" href="#Sims.DerUnknown"><code>Sims.DerUnknown</code></a> — <span class="docstring-category">Type</span>.</div><div><p>An UnknownVariable representing the derivitive of an Unknown, normally created with <code>der(x)</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>x::Unknown</code> : the Unknown variable</p></li><li><p><code>val</code> : initial value, defaults to 0.0</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">a = Unknown()
der(a) + 1
typeof(der(a))</code></pre></div></section><h3><a class="nav-anchor" id="der-1" href="#der-1">der</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.der" href="#Sims.der"><code>Sims.der</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Represents the derivative of an Unknown.</p><pre><code class="language-julia">der(x::Unknown)
der(x::Unknown, val)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>x::Unknown</code> : the Unknown variable</p></li><li><p><code>val</code> : initial value, defaults to 0.0</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">a = Unknown()
der(a) + 1</code></pre></div></section><h3><a class="nav-anchor" id="MExpr-1" href="#MExpr-1">MExpr</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.MExpr" href="#Sims.MExpr"><code>Sims.MExpr</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Represents expressions used in models.</p><pre><code class="language-julia">MExpr(ex::Expr)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>ex::Expr</code> : an expression</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">a = Unknown()
b = Unknown()
d = a + sin(b)
typeof(d)</code></pre></div></section><h3><a class="nav-anchor" id="mexpr-1" href="#mexpr-1">mexpr</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.mexpr" href="#Sims.mexpr"><code>Sims.mexpr</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Create MExpr&#39;s (model expressions). Analogous to <code>expr</code> in Base.</p><p>This is also useful for wrapping user-defined functions where the built-in mechanisms don&#39;t work.</p><pre><code class="language-julia">mexpr(head::Symbol, args::ANY...)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>head::Symbol</code> : the expression head</p></li><li><p><code>args...</code> : values and expressions passed to expression arguments</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>ex::MExpr</code> : a model expression</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">a = Unknown()
b = Unknown()
d = a + sin(b)
typeof(d)
myfun(x) = mexpr(:call, :myfun, x)</code></pre></div></section><h3><a class="nav-anchor" id="Equation-1" href="#Equation-1">Equation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.Equation" href="#Sims.Equation"><code>Sims.Equation</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Equations are used in Models. Right now, Equation is defined as <code>Any</code>, but that may change.  Normally, Equations are of type Unknown, DerUnknown, MExpr, or Array{Equation} (for nesting models).</p><p><strong>Examples</strong></p><p>Models return Arrays of Equations. Here is an example:</p><pre><code class="language-julia">function Vanderpol()
    y = Unknown(1.0, &quot;y&quot;)
    x = Unknown(&quot;x&quot;)
    Equation[
        der(x, -1.0) - ((1 - y^2) * x - y)      # == 0 is assumed
        der(y) - x
    ]
end
dump( Vanderpol() )</code></pre></div></section><h3><a class="nav-anchor" id="Model-1" href="#Model-1">Model</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.Model" href="#Sims.Model"><code>Sims.Model</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Represents a vector of Equations. For now, <code>Equation</code> equals <code>Any</code>, but in the future, it may only include ModelType&#39;s.</p><p>Models return Arrays of Equations. </p><p><strong>Examples</strong></p><pre><code class="language-julia">function Vanderpol()
    y = Unknown(1.0, &quot;y&quot;)
    x = Unknown(&quot;x&quot;)
    Equation[
        der(x, -1.0) - ((1 - y^2) * x - y)      # == 0 is assumed
        der(y) - x
    ]
end
dump( Vanderpol() )
x = sim(Vanderpol(), 50.0)</code></pre></div></section><h3><a class="nav-anchor" id="RefUnknown-1" href="#RefUnknown-1">RefUnknown</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.RefUnknown" href="#Sims.RefUnknown"><code>Sims.RefUnknown</code></a> — <span class="docstring-category">Type</span>.</div><div><p>An UnknownVariable used to allow Arrays as Unknowns. Normally created with <code>getindex</code>. Defined methods include:</p><ul><li><p>getindex</p></li><li><p>length</p></li><li><p>size</p></li><li><p>hcat</p></li><li><p>vcat</p></li></ul></div></section><h3><a class="nav-anchor" id="value-1" href="#value-1">value</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.value" href="#Sims.value"><code>Sims.value</code></a> — <span class="docstring-category">Function</span>.</div><div><p>The value of an object or UnknownVariable.</p><pre><code class="language-julia">value(x)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>x</code> : an object</p></li></ul><p><strong>Returns</strong></p><p>For standard Julia objects, <code>value(x)</code> returns x. For Unknowns and other ModelTypes, returns the current value of the object. <code>value</code> evaluates immediately, so don&#39;t expect to use this in model expressions, except to grab an immediate value.</p><p><strong>Examples</strong></p><pre><code class="language-julia">v = Voltage(value(n1) - value(n2))</code></pre></div></section><h3><a class="nav-anchor" id="name-1" href="#name-1">name</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.name" href="#Sims.name"><code>Sims.name</code></a> — <span class="docstring-category">Function</span>.</div><div><p>The name of an UnknownVariable.</p><pre><code class="language-julia">name(a::UnknownVariable)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>x::UnknownVariable</code></p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>s::AbstractString</code> : either the label of the Unknown or if that&#39;s blank, the symbol name of the Unknown.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">a = Unknown(&quot;var1&quot;)
name(a)</code></pre></div></section><h3><a class="nav-anchor" id="compatible_values-1" href="#compatible_values-1">compatible_values</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.compatible_values" href="#Sims.compatible_values"><code>Sims.compatible_values</code></a> — <span class="docstring-category">Function</span>.</div><div><p>A helper functions to return the base value from an Unknown to use when creating other Unknowns. It is especially useful for taking two model arguments and creating a new Unknown compatible with both arguments.</p><pre><code class="language-julia">compatible_values(x,y)
compatible_values(x)</code></pre><p>It&#39;s still somewhat broken but works for basic cases. No type promotion is currently done.</p><p><strong>Arguments</strong></p><ul><li><p><code>x</code>, <code>y</code> : objects or Unknowns</p></li></ul><p><strong>Returns</strong></p><p>The returned object has zeros of type and length common to both <code>x</code> and <code>y</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">a = Unknown(45.0 + 10im)
x = Unknown(compatible_values(a))   # Initialized to 0.0 + 0.0im.
a = Unknown()
b = Unknown([1., 0.])
y = Unknown(compatible_values(a,b)) # Initialized to [0.0, 0.0].</code></pre></div></section><h3><a class="nav-anchor" id="MTime-1" href="#MTime-1">MTime</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.MTime" href="#Sims.MTime"><code>Sims.MTime</code></a> — <span class="docstring-category">Constant</span>.</div><div><p>The model time - a special unknown variable.</p></div></section><h3><a class="nav-anchor" id="RefBranch-1" href="#RefBranch-1">RefBranch</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.RefBranch" href="#Sims.RefBranch"><code>Sims.RefBranch</code></a> — <span class="docstring-category">Type</span>.</div><div><p>A special ModelType to specify branch flows into nodes. When the model is flattened, equations are created to zero out branch flows into nodes. </p><p>See also <a href="#branch">Branch</a>.</p><pre><code class="language-julia">RefBranch(n, i) </code></pre><p><strong>Arguments</strong></p><ul><li><p><code>n</code> : the reference node.</p></li><li><p><code>i</code> : the flow variable that goes with this node.</p></li></ul><p><strong>References</strong></p><p>This nodal description is based on work by <a href="http://web.ict.kth.se/~dbro/">David Broman</a>. See the following:</p><ul><li><p>http://www.eecs.berkeley.edu/Pubs/TechRpts/2012/EECS-2012-173.pdf</p></li><li><p>http://www.bromans.com/software/mkl/mkl-source-1.0.0.zip</p></li><li><p>https://github.com/david-broman/modelyze</p></li></ul><p><a href="https://github.com/david-broman/modelyze">Modelyze</a> has both <code>RefBranch</code> and <code>Branch</code>.</p><p><strong>Examples</strong></p><p>Here is an example of RefBranch used in the definition of a HeatCapacitor in the standard library. <code>hp</code> is the reference node (a HeatPort aka Temperature), and <code>Q_flow</code> is the flow variable.</p><pre><code class="language-julia">function HeatCapacitor(hp::HeatPort, C::Signal)
    Q_flow = HeatFlow(compatible_values(hp))
    @equations begin
        RefBranch(hp, Q_flow)
        C .* der(hp) = Q_flow
    end
end</code></pre><p>Here is the definition of SignalCurrent from the standard library a model that injects current (a flow variable) between two nodes:</p><pre><code class="language-julia">function SignalCurrent(n1::ElectricalNode, n2::ElectricalNode, I::Signal)  
    @equations begin
        RefBranch(n1, I) 
        RefBranch(n2, -I) 
    end
end</code></pre></div></section><h3><a class="nav-anchor" id="Branch-1" href="#Branch-1">Branch</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.Branch" href="#Sims.Branch"><code>Sims.Branch</code></a> — <span class="docstring-category">Function</span>.</div><div><p>A helper Model to connect a branch between two different nodes and specify potential between nodes and the flow between nodes.</p><p>See also <a href="#refbranch">RefBranch</a>.</p><pre><code class="language-julia">Branch(n1, n2, v, i)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>n1</code> : the positive reference node.</p></li><li><p><code>n2</code> : the negative reference node.</p></li><li><p><code>v</code> : the potential variable between nodes.</p></li><li><p><code>i</code> : the flow variable between nodes.</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>::Array{Equation}</code> : the model, consisting of a RefBranch entry for each node and an equation assigning <code>v</code> to <code>n1 - n2</code>.</p></li></ul><p><strong>References</strong></p><p>This nodal description is based on work by <a href="http://web.ict.kth.se/~dbro/">David Broman</a>. See the following:</p><ul><li><p>http://www.eecs.berkeley.edu/Pubs/TechRpts/2012/EECS-2012-173.pdf</p></li><li><p>http://www.bromans.com/software/mkl/mkl-source-1.0.0.zip</p></li><li><p>https://github.com/david-broman/modelyze</p></li></ul><p><strong>Examples</strong></p><p>Here is the definition of an electrical resistor in the standard library:</p><pre><code class="language-julia">function Resistor(n1::ElectricalNode, n2::ElectricalNode, R::Signal)
    i = Current(compatible_values(n1, n2))
    v = Voltage(value(n1) - value(n2))
    @equations begin
        Branch(n1, n2, v, i)
        v = R .* i
    end
end</code></pre></div></section><h3><a class="nav-anchor" id="InitialEquation-1" href="#InitialEquation-1">InitialEquation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.InitialEquation" href="#Sims.InitialEquation"><code>Sims.InitialEquation</code></a> — <span class="docstring-category">Type</span>.</div><div><p>A ModelType describing initial equations. Current support is limited and may be broken. There are no tests. The idea is that the equations provided will only be used during the initial solution.</p><pre><code class="language-julia">InitialEquation(eqs)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>x::Unknown</code> : the quantity to be initialized</p></li><li><p><code>eqs::Array{Equation}</code> : a vector of equations, each to be equated to zero during the initial equation solution.</p></li></ul></div></section><h3><a class="nav-anchor" id="PassedUnknown-1" href="#PassedUnknown-1">PassedUnknown</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.PassedUnknown" href="#Sims.PassedUnknown"><code>Sims.PassedUnknown</code></a> — <span class="docstring-category">Type</span>.</div><div><p>An UnknownVariable used as a helper for the <code>delay</code> function.  It is an identity unknown, but it doesn&#39;t replace with a reference to the y array.</p><p>PassedUnknown(ref::UnknownVariable)</p><p><strong>Arguments</strong></p><ul><li><p><code>ref::UnknownVariable</code> : an Unknown</p></li></ul></div></section><h3><a class="nav-anchor" id="delay-1" href="#delay-1">delay</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.delay" href="#Sims.delay"><code>Sims.delay</code></a> — <span class="docstring-category">Function</span>.</div><div><p>A Model specifying a delay to an Unknown.</p><p>Internally, Unknowns that are delayed store past history. This is interpolated as needed to find the delayed quantity.</p><pre><code class="language-julia">delay(x::Unknown, val)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>x::Unknown</code> : the quantity to be delayed.</p></li><li><p><code>val</code> : the value of the delay; may be an object or Unknown.</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>::MExpr</code> : a delayed Unknown</p></li></ul></div></section><h3><a class="nav-anchor" id="UnknownReactive-1" href="#UnknownReactive-1">UnknownReactive</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.UnknownReactive" href="#Sims.UnknownReactive"><code>Sims.UnknownReactive</code></a> — <span class="docstring-category">Type</span>.</div><div><p>An abstract type representing Unknowns that use the Reactive.jl package. The main types included are <code>Discrete</code> and <code>Parameter</code>. <code>Discrete</code> is normally used as inputs inside of models and includes an initial value that is reset at every simulation run. <code>Parameter</code> is used to pass information from outside to the model. Use this for repeated simulation runs based on parameter variations.</p><p>Because they are Unknowns, UnknownReactive types form MExpr&#39;s when used in expressions just like Unknowns.</p><p>Many of the methods from Reactive.jl are supported, including <code>lift</code>, <code>foldl</code>, <code>filter</code>, <code>dropif</code>, <code>droprepeats</code>, <code>keepwhen</code>, <code>dropwhen</code>, <code>sampleon</code>, and <code>merge</code>. Use <code>reinit</code> to reinitialize a Discrete or a Parameter (equivalent to <code>Reactive.push!</code>).</p></div></section><h3><a class="nav-anchor" id="Discrete-1" href="#Discrete-1">Discrete</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.Discrete" href="#Sims.Discrete"><code>Sims.Discrete</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Discrete is a type for discrete variables. These are only changed during events. They are not used by the integrator. Because they are not used by the integrator, almost any type can be used as a discrete variable. Discrete variables wrap a Signal from the <a href="http://julialang.org/Reactive.jl/">Reactive.jl</a> package.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">Discrete(initialvalue = 0.0)
Discrete(x::Reactive.Signal, initialvalue)</code></pre><p>Without arguments, <code>Discrete()</code> uses an initial value of 0.0.</p><p><strong>Arguments</strong></p><ul><li><p><code>initialvalue</code> : initial value and type information, defaults to 0.0</p></li><li><p><code>x::Reactive.Signal</code> : a <code>Signal</code> from the Reactive.jl package.</p></li></ul><p><strong>Details</strong></p><p><code>Discrete</code> is the main input type for discrete variables. By default, it wraps a <code>Reactive.Signal</code> type. <code>Discrete</code> variables support data flow using Reactive.jl. Use <code>reinit</code> to update Discrete variables. Use <code>lift</code> to create additional <code>UnknownReactive</code> types that depend on the <code>Discrete</code> input. Use <code>foldl</code> for actions that remember state. For more information on <em>Reactive Programming</em>, see the <a href="http://julialang.org/Reactive.jl/">Reactive.jl</a> package.</p></div></section><h3><a class="nav-anchor" id="Parameter-1" href="#Parameter-1">Parameter</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.Parameter" href="#Sims.Parameter"><code>Sims.Parameter</code></a> — <span class="docstring-category">Type</span>.</div><div><p>An <code>UnknownReactive</code> type that is useful for passing parameters at the top level.</p><p><strong>Arguments</strong></p><pre><code class="language-julia">Parameter(x = 0.0)
Parameter(sig::Reactive.Signal}</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>x</code> : initial value and type information, defaults to 0.0</p></li><li><p><code>sig</code> : A `Reactive.Signal </p></li></ul><p><strong>Details</strong></p><p>Parameters can be reinitialized with <code>reinit</code>, either externally or inside models. If you want Parameters to be read-only, wrap them in another UnknownReactive before passing to models. For example, use <code>param_read_only = lift(x -&gt; x, param)</code>.</p><p><strong>Examples</strong></p><p>Sims.Examples.Basics.VanderpolWithParameter takes one model argument <code>mu</code>. Here is an example of it used externally with a Parameter:</p><pre><code class="language-julia">mu = Parameter(1.0)
ss = create_simstate(VanderpolWithParameter(mu))
vwp1 = sim(ss, 10.0)
reinit(mu, 1.5)
vwp2 = sim(ss, 10.0)
reinit(mu, 1.0)
vwp3 = sim(ss, 10.0) # should be the same as vwp1</code></pre></div></section><h3><a class="nav-anchor" id="reinit-1" href="#reinit-1">reinit</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.reinit" href="#Sims.reinit"><code>Sims.reinit</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>reinit</code> is used in Event responses to redefine variables. </p><pre><code class="language-julia">reinit(x, y)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>x</code> : the object to be reinitialized; can be a Discrete, Parameter, an Unknown, or DerUnknown</p></li><li><p><code>y</code> : value for redefinition.</p></li></ul><p><strong>Returns</strong></p><ul><li><p>A value stored just prior to an event.</p></li></ul><p><strong>Examples</strong></p><p>Here is the definition of Step in the standard library:</p><pre><code class="language-julia">function Step(y::Signal, 
              height = 1.0,
              offset = 0.0, 
              startTime = 0.0)
    ymag = Discrete(offset)
    @equations begin
        y = ymag  
        Event(MTime - startTime,
              Equation[reinit(ymag, offset + height)],   # positive crossing
              Equation[reinit(ymag, offset)])            # negative crossing
    end
end</code></pre><p>See also <a href="../../lib/electrical/#idealthyristor">IdealThyristor</a> in the standard library.</p></div></section><h3><a class="nav-anchor" id="LeftVar-1" href="#LeftVar-1">LeftVar</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.LeftVar" href="#Sims.LeftVar"><code>Sims.LeftVar</code></a> — <span class="docstring-category">Type</span>.</div><div><p>A helper type needed to mark unknowns as left-side variables in assignments during event responses.</p></div></section><h3><a class="nav-anchor" id="lift-1" href="#lift-1">lift</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.lift" href="#Reactive.lift"><code>Reactive.lift</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Create a new UnknownReactive type that links to existing UnknownReactive types (like Discrete and Parameter).</p><pre><code class="language-julia">lift{T}(f::Function, inputs::UnknownReactive{T}...)
lift{T}(f::Function, t::Type, inputs::UnknownReactive{T}...)
map{T}(f::Function, inputs::UnknownReactive{T}...)
map{T}(f::Function, t::Type, inputs::UnknownReactive{T}...)</code></pre><p>See also <a href="http://julialang.org/Reactive.jl/api.html#lift">Reactive.lift</a>] and the <a href="#liftd">@liftd</a> helper macro to ease writing expressions.</p><p>Note that <code>lift</code> is being transitioned to <code>Base.map</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>f::Function</code> : the transformation function; takes one argument for each <code>inputs</code> argument</p></li><li><p><code>inputs::UnknownReactive</code> : signals to apply <code>f</code> to</p></li><li><p><code>t::Type</code> : optional output type</p></li></ul><p>Note: you cannot use Unknowns or MExprs in <code>f</code>, the transformation function.</p><p><strong>Examples</strong></p><pre><code class="language-julia">a = Discrete(1)
b = lift(x -&gt; x + 1, a)
c = lift((x,y) -&gt; x * y, a, b)
reinit(a, 3)
b    # now 4
c    # now 12</code></pre><p>See <a href="../../lib/electrical/#idealthyristor">IdealThyristor</a> in the standard library.</p><p>Note that you can use Discretes and Parameters in expressions that create MExprs. Compare the following:</p><pre><code class="language-julia">j = lift((x,y) = x * y, a, b)
k = a * b</code></pre><p>In this example, <code>j</code> uses <code>lift</code> to immediately connect to <code>a</code> and <code>b</code>. <code>k</code> is an MExpr with <code>a * b</code> embedded inside. When <code>j</code> is used in a model, the <code>j</code> UnknownReactive object is embedded in the model, and it is updated automatically. With <code>k</code>, <code>a * b</code> is inserted into the model, so it&#39;s more like a macro; <code>a * b</code> will be evaluated every time in the residual calculation. The advantage of the <code>a * b</code> approach is that the expression can include Unknowns.</p></div></section><h3><a class="nav-anchor" id="foldl-1" href="#foldl-1">foldl</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.foldl" href="#Base.foldl"><code>Base.foldl</code></a> — <span class="docstring-category">Function</span>.</div><div><p>&quot;Fold over time&quot; – an UnknownReactive updated based on stored state and additional inputs.</p><p>See also <a href="http://julialang.org/Reactive.jl/api.html#foldl">Reactive.foldl</a>].</p><pre><code class="language-julia">foldl(f::Function, v0, inputs::UnknownReactive{T}...)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>f::Function</code> : the transformation function; the first argument is the stored state followed by one argument for each <code>inputs</code> argument</p></li><li><p><code>v0</code> : initial value of the stored state</p></li><li><p><code>inputs::UnknownReactive</code> : signals to apply <code>f</code> to</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>::UnknownReactive</code></p></li></ul><p><strong>Examples</strong></p><p>See the definition of <a href="#pre">pre</a> for an example.</p></div></section><h3><a class="nav-anchor" id="@liftd-1" href="#@liftd-1">@liftd</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.@liftd" href="#Sims.@liftd"><code>Sims.@liftd</code></a> — <span class="docstring-category">Macro</span>.</div><div><p>A helper for an expression of UnknownReactive variables</p><pre><code class="language-julia">@liftd exp</code></pre><p>Note that the expression should not contain Unknowns. To mark the Discrete variables, enter them as Symbols. This uses <code>lift()</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>exp</code> : an expression, usually containing other Discrete variables</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>::Discrete</code> : a signal</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">x = Discrete(true)
y = Discrete(false)
z = @liftd :x &amp; !:y
## equivalent to:
z2 = lift((x, y) -&gt; x &amp; !y, x, y)</code></pre></div></section><h3><a class="nav-anchor" id="pre-1" href="#pre-1">pre</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.pre" href="#Sims.pre"><code>Sims.pre</code></a> — <span class="docstring-category">Function</span>.</div><div><p>An <code>UnknownReactive</code> based on the previous value of <code>x</code> (normally prior to an event).</p><p>See also <a href="#event">Event</a>.</p><pre><code class="language-julia">pre(x::UnknownReactive)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>x::Discrete</code></p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>::UnknownReactive</code></p></li></ul></div></section><h3><a class="nav-anchor" id="Event-1" href="#Event-1">Event</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.Event" href="#Sims.Event"><code>Sims.Event</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Event is the main type used for hybrid modeling. It contains a condition for root finding and model expressions to process after positive and negative root crossings are detected.</p><p>See also <a href="#boolevent">BoolEvent</a>.</p><pre><code class="language-julia">Event(condition::ModelType, pos_response, neg_response)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>condition::ModelType</code> : an expression used for the event detection.</p></li><li><p><code>pos_response</code> : an expression indicating what to do when the condition crosses zero positively. May be Model or MExpr.</p></li><li><p><code>neg_response::Model</code> : an expression indicating what to do when the condition crosses zero in the negative direction. Defaults to Equation[].</p></li></ul><p><strong>Examples</strong></p><p>See <a href="../../lib/electrical/#idealthyristor">IdealThyristor</a> in the standard library.</p></div></section><h3><a class="nav-anchor" id="BoolEvent-1" href="#BoolEvent-1">BoolEvent</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.BoolEvent" href="#Sims.BoolEvent"><code>Sims.BoolEvent</code></a> — <span class="docstring-category">Function</span>.</div><div><p>BoolEvent is a helper for attaching an event to a boolean variable. In conjunction with <code>ifelse</code>, this allows constructs like Modelica&#39;s if blocks.</p><p>Note that the lengths of <code>d</code> and <code>condition</code> must match for arrays.</p><pre><code class="language-julia">BoolEvent(d::Discrete, condition::ModelType)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>d::Discrete</code> : the discrete variable.</p></li><li><p><code>condition::ModelType</code> : the model expression(s) </p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>::Event</code> : a model Event</p></li></ul><p><strong>Examples</strong></p><p>See <a href="../../lib/electrical/#idealdiode">IdealDiode</a> and <a href="../../lib/blocks/#limiter">Limiter</a> in the standard library.</p></div></section><h3><a class="nav-anchor" id="ifelse-1" href="#ifelse-1">ifelse</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ifelse" href="#Base.ifelse"><code>Base.ifelse</code></a> — <span class="docstring-category">Function</span>.</div><div><p>A function allowing if-then-else action for objections and expressions.</p><p>Note that when this is used in a model, it does not trigger an event. You need to use <code>Event</code> or <code>BoolEvent</code> for that. It is used often in conjunction with <code>Event</code>.</p><pre><code class="language-julia">ifelse(x, y)
ifelse(x, y, z)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>x</code> : the condition, a Bool or ModelType</p></li><li><p><code>y</code> : the value to return when true</p></li><li><p><code>z</code> : the value to return when false, defaults to <code>nothing</code></p></li></ul><p><strong>Returns</strong></p><ul><li><p>Either <code>y</code> or <code>z</code></p></li></ul><p><strong>Examples</strong></p><p>See <a href="../../lib/electrical/#deadzone">DeadZone</a> and <a href="../../lib/blocks/#limiter">Limiter</a> in the standard library.</p></div></section><h3><a class="nav-anchor" id="StructuralEvent-1" href="#StructuralEvent-1">StructuralEvent</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.StructuralEvent" href="#Sims.StructuralEvent"><code>Sims.StructuralEvent</code></a> — <span class="docstring-category">Type</span>.</div><div><p>StructuralEvent defines a type for elements that change the structure of the model. An event is created where the condition crosses zero. When the event is triggered, the model is re-flattened after replacing <code>default</code> with <code>new_relation</code> in the model.</p><pre><code class="language-julia">StructuralEvent(condition::MExpr, default, new_relation::Function,
                pos_response, neg_response)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>condition::MExpr</code> : an expression that will trigger the event at a zero crossing</p></li><li><p><code>default</code> : the default Model used</p></li><li><p><code>new_relation</code> : a function that returns a model that will replace the default model when the condition triggers the event.</p></li><li><p><code>pos_response</code> : an expression indicating what to do when the condition crosses zero positively. Defaults to Equation[].</p></li><li><p><code>neg_response::Model</code> : an expression indicating what to do when the condition crosses zero in the negative direction. Defaults to Equation[].</p></li></ul><p><strong>Examples</strong></p><p>Here is an example from examples/breaking_pendulum.jl:</p><pre><code class="language-julia">function FreeFall(x,y,vx,vy)
    @equations begin
        der(x) = vx
        der(y) = vy
        der(vx) = 0.0
        der(vy) = -9.81
    end
end

function Pendulum(x,y,vx,vy)
    len = sqrt(x.value^2 + y.value^2)
    phi0 = atan2(x.value, -y.value) 
    phi = Unknown(phi0)
    phid = Unknown()
    @equations begin
        der(phi) = phid
        der(x) = vx
        der(y) = vy
        x = len * sin(phi)
        y = -len * cos(phi)
        der(phid) = -9.81 / len * sin(phi)
    end
end

function BreakingPendulum()
    x = Unknown(cos(pi/4), &quot;x&quot;)
    y = Unknown(-cos(pi/4), &quot;y&quot;)
    vx = Unknown()
    vy = Unknown()
    Equation[
        StructuralEvent(MTime - 5.0,     # when time hits 5 sec, switch to FreeFall
            Pendulum(x,y,vx,vy),
            () -&gt; FreeFall(x,y,vx,vy))
    ]
end

p_y = sim(BreakingPendulum(), 6.0)  </code></pre></div></section><h3><a class="nav-anchor" id="@equations-1" href="#@equations-1">@equations</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.@equations" href="#Sims.@equations"><code>Sims.@equations</code></a> — <span class="docstring-category">Macro</span>.</div><div><p>A helper to make writing Models a little easier. It allows the use of <code>=</code> in model equations.</p><pre><code class="language-julia">@equations begin
    ...
end</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>eq</code> : the model equations, normally in a <code>begin</code> - <code>end</code> block.</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>::Array{Equation}</code></p></li></ul><p><strong>Examples</strong></p><p>The following are both equivalent:</p><pre><code class="language-julia">function Vanderpol1()
    y = Unknown(1.0, &quot;y&quot;)
    x = Unknown(&quot;x&quot;)
    Equation[
        der(x, -1.0) - ((1 - y^2) * x - y)      # == 0 is assumed
        der(y) - x
    ]
end
function Vanderpol2()
    y = Unknown(1.0, &quot;y&quot;) 
    x = Unknown(&quot;x&quot;)
    @equations begin
        der(x, -1.0) = (1 - y^2) * x - y
        der(y) = x
    end
end</code></pre></div></section><footer><hr/><a class="previous" href="../basics.html"><span class="direction">Previous</span><span class="title">Basics</span></a><a class="next" href="sim.html"><span class="direction">Next</span><span class="title">Simulations</span></a></footer></article></body></html>
