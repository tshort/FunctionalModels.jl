<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Simulations · Sims.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../../versions.js"></script></head><body><nav class="toc"><h1>Sims.jl</h1><form class="search" action="../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="../basics.html">Basics</a></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="main.html">Building models</a></li><li class="current"><a class="toctext" href="sim.html">Simulations</a><ul class="internal"></ul></li><li><a class="toctext" href="utils.html">Utilities</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/types.html">The Sims standard library</a></li><li><a class="toctext" href="../lib/kinetics.html">Chemical kinetics</a></li><li><a class="toctext" href="../lib/blocks.html">Control and signal blocks</a></li><li><a class="toctext" href="../lib/electrical.html">Analog electrical models</a></li><li><a class="toctext" href="../lib/heat_transfer.html">Heat transfer models</a></li><li><a class="toctext" href="../lib/powersystems.html">Power systems models</a></li><li><a class="toctext" href="../lib/rotational.html">Rotational mechanics</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/basics.html">Examples using basic models</a></li><li><a class="toctext" href="../examples/lib.html">Sims.Lib</a></li><li><a class="toctext" href="../examples/tiller.html">Tiller examples</a></li></ul></li><li><a class="toctext" href="../design.html">Design</a></li><li><a class="toctext" href="../NEWS.html">Release notes</a></li><li><a class="toctext" href="../LICENSE.html">License</a></li></ul></nav><article id="docs"><header><nav><ul><li>API</li><li><a href="sim.html">Simulations</a></li></ul></nav><hr/></header><ul><ul><ul><li><a href="sim.html#dasslsim-1">dasslsim</a></li><li><a href="sim.html#sunsim-1">sunsim</a></li></ul></ul><li><a href="sim.html#Simulations-1">Simulations</a></li><ul><ul><li><a href="sim.html#sim-1">sim</a></li><li><a href="sim.html#EquationSet-1">EquationSet</a></li><li><a href="sim.html#elaborate-1">elaborate</a></li><li><a href="sim.html#SimFunctions-1">SimFunctions</a></li><li><a href="sim.html#Sim-1">Sim</a></li><li><a href="sim.html#SimState-1">SimState</a></li><li><a href="sim.html#create_sim-1">create_sim</a></li><li><a href="sim.html#create_simstate-1">create_simstate</a></li><li><a href="sim.html#SimResult-1">SimResult</a></li></ul></ul></ul><h3><a class="nav-anchor" id="dasslsim-1" href="#dasslsim-1">dasslsim</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.dasslsim" href="#Sims.dasslsim"><code>Sims.dasslsim</code></a> — <span class="docstring-category">Function</span>.</div><div><p>The solver that uses DASKR, a variant of DASSL.</p><p>See <a href="#sim">sim</a> for the interface.</p></div></section><h3><a class="nav-anchor" id="sunsim-1" href="#sunsim-1">sunsim</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.sunsim" href="#Sims.sunsim"><code>Sims.sunsim</code></a> — <span class="docstring-category">Function</span>.</div><div><p>The solver that uses Sundials.</p><p>See <a href="#sim">sim</a> for the interface.</p></div></section><h1><a class="nav-anchor" id="Simulations-1" href="#Simulations-1">Simulations</a></h1><p>Various functions for simulations and building simulation objects from models.</p><h3><a class="nav-anchor" id="sim-1" href="#sim-1">sim</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.sim" href="#Sims.sim"><code>Sims.sim</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>sim</code> is the name of the default solver used to simulate Sims models and also shows the generic simulation API for available solvers (currently <code>dasslsim</code> and <code>sunsim</code>). The default solver is currently <code>dasslsim</code> if DASSL is available.</p><p><code>sim</code> has many method definitions to accomodate solutions based on intermediate model representations. Also, both positional and keyword arguments are supported (use one or the other after the first argument).</p><pre><code class="language-julia">sim(m::Model, tstop::Float64=1.0, Nsteps::Int=500, reltol::Float64=1e-4, abstol::Float64=1e-4, init::Symbol=:Ya_Ydp, alg::Bool=true)
sim(m::Model; tstop::Float64=1.0, Nsteps::Int=500, reltol::Float64=1e-4, abstol::Float64=1e-4, init::Symbol=:Ya_Ydp, alg::Bool=true)
sim(m::Sim, tstop::Float64=1.0, Nsteps::Int=500, reltol::Float64=1e-4, abstol::Float64=1e-4, init::Symbol=:Ya_Ydp, alg::Bool=true)
sim(m::Sim; tstop::Float64=1.0, Nsteps::Int=500, reltol::Float64=1e-4, abstol::Float64=1e-4, init::Symbol=:Ya_Ydp, alg::Bool=true)
sim(m::SimState, tstop::Float64=1.0, Nsteps::Int=500, reltol::Float64=1e-4, abstol::Float64=1e-4, init::Symbol=:Ya_Ydp, alg::Bool=true)
sim(m::SimState; tstop::Float64=1.0, Nsteps::Int=500, reltol::Float64=1e-4, abstol::Float64=1e-4, init::Symbol=:Ya_Ydp, alg::Bool=true)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>m::Model</code> : a Model</p></li><li><p><code>sm::Sim</code> : a simulation object</p></li><li><p><code>ss::SimState</code> : a simulation object</p></li><li><p><code>tstop::Float64</code> : the simulation stopping time [secs], default = 1.0</p></li><li><p><code>Nsteps::Int</code> : the number of simulation steps, default = 500</p></li><li><p><code>reltol::Float64</code> : the relative tolerance, default = 1e-4</p></li><li><p><code>abstol::Float64</code> : the absolute tolerance, default = 1e-4</p></li><li><p><code>init</code> : initialization of the model; options include:</p><ul><li><p><code>:none</code> : no initialization</p></li><li><p><code>:Ya_Ydp</code> :  given <code>Y_d</code>, calculate <code>Y_a</code> and <code>Y&#39;_d</code> (the default)</p></li><li><p><code>:Y</code> :  given <code>Y&#39;</code>, calculate <code>Y</code></p></li><li><p><code>alg</code> : indicates whether algebraic variables should be included in the error estimate (default is true)</p></li></ul></li></ul><p><strong>Returns</strong></p><ul><li><p><code>::SimResult</code> : the simulation result</p></li></ul><p>A number of optional packages can be used with results, including:</p><ul><li><p>Winston - plotting: <code>plot(y::SimResult)</code></p></li><li><p>Gaston - plotting: <code>gplot(y::SimResult)</code> </p></li><li><p>DataFrames - conversion to a DataFrame: <code>convert(DataFrame, y::SimResult)</code> </p></li><li><p>Gadfly - plotting: <code>plot(y::SimResult, ...)</code> </p></li></ul><p>For each of these, the package must be installed, and the package pulled in with <code>require</code> or <code>using</code>.</p><p><strong>Details</strong></p><p>The main steps in converting to a model and doing a simulation are:</p><pre><code class="language-julia">eqs::EquationSet = elaborate(m::Model)   # flatten the model
sm::Sim = create_sim(eqs::EquationSet)   # prepare for simulation
sm::SimState = create_simstate(sm::Sim)  # prepare for simulation II
y::SimResult = sim(ss::SimState)         # simulate</code></pre><p>The following are equivalent:</p><pre><code class="language-julia">y = sim(create_simstate(create_sim(elaborate(m))))
y = sim(m)</code></pre><p><strong>Example</strong></p><pre><code class="language-julia">using Sims
function Vanderpol()
    y = Unknown(1.0, &quot;y&quot;)   # The 1.0 is the initial value. &quot;y&quot; is for plotting.
    x = Unknown(&quot;x&quot;)        # The initial value is zero if not given.
    # The following gives the return value which is a list of equations.
    # Expressions with Unknowns are kept as expressions. Expressions of
    # regular variables are evaluated immediately (like normal).
    @equations begin
        # The -1.0 in der(x, -1.0) is the initial value for the derivative 
        der(x, -1.0) = (1 - y^2) * x - y 
        der(y) = x
    end
end

v = Vanderpol()       # returns the hierarchical model
y = sunsim(v, 50.0)

plot(y)</code></pre></div></section><h3><a class="nav-anchor" id="EquationSet-1" href="#EquationSet-1">EquationSet</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.EquationSet" href="#Sims.EquationSet"><code>Sims.EquationSet</code></a> — <span class="docstring-category">Type</span>.</div><div><p>A representation of a flattened model, normally created with <code>elaborate(model)</code>. <code>sim</code> uses an elaborated model for simulations.</p><p>Contains the hierarchical equations, flattened equations, flattened initial equations, events, event response functions, and a map of Unknown nodes.</p></div></section><h3><a class="nav-anchor" id="elaborate-1" href="#elaborate-1">elaborate</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.elaborate" href="#Sims.elaborate"><code>Sims.elaborate</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>elaborate</code> is the main elaboration function that returns a flattened model representation that can be used by <code>sim</code>.</p><pre><code class="language-julia">elaborate(a::Model)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>a::Model</code> : the input model</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>::EquationSet</code> : the flattened model</p></li></ul><p><strong>Details</strong></p><p>The main steps in flattening are:</p><ul><li><p>Replace fixed initial values.</p></li><li><p>Flatten models and populate <code>eq.equations</code>.</p></li><li><p>Pull out InitialEquations and populate <code>eq.initialequations</code></p></li><li><p>Pull out Events and populate <code>eq.events</code>.</p></li><li><p>Handle StructuralEvents.</p></li><li><p>Collect nodes and populate <code>eq.nodeMap</code>.</p></li><li><p>Strip out MExpr&#39;s from expressions.</p></li><li><p>Remove empty equations.</p></li></ul><p>There is currently no real symbolic processing (sorting, index reduction, or any of the other stuff a fancy modeling tool would do).</p><p>In EquationSet, <code>model</code> contains equations and StructuralEvents. When a StructuralEvent triggers, the entire model is elaborated again. The first step is to replace StructuralEvents that have activated with their new_relation in model. Then, the rest of the EquationSet is reflattened using <code>model</code> as the starting point.</p></div></section><h3><a class="nav-anchor" id="SimFunctions-1" href="#SimFunctions-1">SimFunctions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.SimFunctions" href="#Sims.SimFunctions"><code>Sims.SimFunctions</code></a> — <span class="docstring-category">Type</span>.</div><div><p>The set of functions used in the DAE solution. Includes an initial set of equations, a residual function, and several functions for detecting and responding to events.</p><p>All functions take (t,y,yp) as arguments. {TODO: is this still right?}</p></div></section><h3><a class="nav-anchor" id="Sim-1" href="#Sim-1">Sim</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.Sim" href="#Sims.Sim"><code>Sims.Sim</code></a> — <span class="docstring-category">Type</span>.</div><div><p>A type for holding several simulation objects needed for simulation, normally created with <code>create_sim(eqs)</code>. </p></div></section><h3><a class="nav-anchor" id="SimState-1" href="#SimState-1">SimState</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.SimState" href="#Sims.SimState"><code>Sims.SimState</code></a> — <span class="docstring-category">Type</span>.</div><div><p>The top level type for holding all simulation objects needed for simulation, including a Sim. Normally created with <code>create_simstate(sim)</code>.</p></div></section><h3><a class="nav-anchor" id="create_sim-1" href="#create_sim-1">create_sim</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.create_sim" href="#Sims.create_sim"><code>Sims.create_sim</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>create_sim</code> converts a model to a Sim.</p><pre><code class="language-julia">create_sim(m::Model)
create_sim(eq::EquationSet)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>m::Model</code> : a Model</p></li><li><p><code>eq::EquationSet</code> : a flattened model</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>::Sim</code> : a simulation object</p></li></ul></div></section><h3><a class="nav-anchor" id="create_simstate-1" href="#create_simstate-1">create_simstate</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.create_simstate" href="#Sims.create_simstate"><code>Sims.create_simstate</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>create_simstate</code> converts a Sim is the main conversion function that returns a SimState, a simulation object with state history.</p><pre><code class="language-julia">create_simstate(m::Model)
create_simstate(eq::EquationSet)
create_simstate(sm::Sim)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>m::Model</code> : a Model</p></li><li><p><code>eq::EquationSet</code> : a flattened model</p></li><li><p><code>sm::Sim</code> : a simulation object</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>::Sim</code> : a simulation object</p></li></ul></div></section><h3><a class="nav-anchor" id="SimResult-1" href="#SimResult-1">SimResult</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sims.SimResult" href="#Sims.SimResult"><code>Sims.SimResult</code></a> — <span class="docstring-category">Type</span>.</div><div><p>A type holding simulation results from <code>sim</code>, <code>dasslsim</code>, or <code>sunsim</code>. Includes a matrix of results and a vector of column names.</p></div></section><footer><hr/><a class="previous" href="main.html"><span class="direction">Previous</span><span class="title">Building models</span></a><a class="next" href="utils.html"><span class="direction">Next</span><span class="title">Utilities</span></a></footer></article></body></html>
